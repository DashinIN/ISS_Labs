# Описание проекта
Необходимо разработать модель классификации, которая на основе различных характеристик мобильного телефона сможет предсказать его ценовой диапазон (price_range).

Целевой переменной является price_range, которая принимает значения от 0 до 3, где:
• 0: бюджетные телефоны
• 1: телефоны низко-среднего сегмента
• 2: телефоны среднего и высокого сегмента
• 3: премиум телефоны

## Результаты разведочного анализа (EDA)

### Действия по очистке данных:
1. Удалены записи с нулевыми значениями в полях:
   - sc_w (ширина экрана)
   - pc (основная камера)
   - fc (фронтальная камера)
   - px_height (высота в пикселях)
2. Оптимизированы типы данных для всех столбцов
3. Проверено отсутствие дубликатов
4. Проверено отсутствие пропущенных значений

### Основные выводы:
1. [Распределение мощности батареи](./eda/battery_distribution.png):
   - Наблюдается равномерное распределение
   - Отсутствуют явные выбросы

2. [RAM vs Ценовой диапазон](./eda/ram_price_scatter.png):
   - Выявлена сильная положительная корреляция
   - Чем больше RAM, тем выше ценовой диапазон
   - Четкое разделение ценовых категорий

3. [Разрешение экрана](./eda/resolution.png):
   - Линейная зависимость между высотой и шириной
   - Стандартное соотношение сторон у большинства устройств

4. [Матрица корреляций](./eda/correlation_matrix.png):
   - Наибольшая корреляция с ценой у RAM (0.92)
   - Умеренная корреляция у battery_power (0.22)
   - Слабые корреляции между остальными признаками

5. [Интерактивный график RAM vs Батарея](./eda/interactive_plot.html):
   - Подтверждает важность RAM для определения цены
   - Показывает кластеризацию устройств по ценовым категориям


## Запуск проекта
```bash
git clone https://github.com/DashinIN/ISS_Labs.git
cd IIS-Labs
python -m venv .venv
.venv/Scripts/activate
pip install -r requirements.txt
```

## Структура проекта
- `data/` - исходные и очищенные данные
- `eda/` - графики и результаты анализа
- `requirements.txt` - зависимости проекта

# Запуск MLFlow
1. Перейти в директорию ./mlflow:
```
   cd mlflow/
```
2. Выполнить скрипт для запуска сервера:
```
   sh run.sh
```

# Создание сервиса
### 1. Основной API-сервер с FastAPI: <br/>

• Обработка запросов на корневом маршруте (`/`) — возвращает простое сообщение `{'Hello': 'world'}` <br/>
• Обработка запросов на маршруте `/api/prediction` — принимает идентификатор объекта и его признаки,   использует модель для предсказания и возвращает price_range <br/>

### 2. Обработчик предсказаний модели:<br/>

• При создании экземпляра класса загружает модель из файла `model.pkl` <br/>
• Логирует успешность загрузки или ошибки. <br/>
• Метод `predict` принимает словарь с признаками объекта, преобразует его в pandas.DataFrame, подает на вход   модели и возвращает предсказание. <br/>

### 3. Dockerfile для контейнеризации сервиса: <br/>
Данный файл описывает инструкцию по созданию Docker-образа для запуска FastAPI-сервиса.<br/>

• Копирование всех файлов приложения в контейнер<br/>
• Установка зависимостей из `requirements.txt`<br/>
• Указание рабочей директории и порта для запуска<br/>
• Обеспечение возможности подключения модели через монтируемую папку (`/models`)<br/>
• Запуск приложения с помощью uvicorn

### 4.  requirements.txt для зависимостей
Список необходимых Python-библиотек для работы сервиса:<br/>

• fastapi и uvicorn — для создания и запуска веб-сервиса<br/>
• pandas — для работы с данными<br/>
• pickle4 — для загрузки сохраненной модели<br/>
• scikit-learn — для выполнения предсказаний с помощью обученной модели<br/>

### 5. MLFlow
Для работы с MLflow локально. Он выполняет загрузку модели из хранилища MLflow Tracking Server и сохраняет ее в файл model.pkl для дальнейшего использования. <br/>

Создание образа: <br/>
```
   docker build . --tag estate_model:0
```
Запуск контейнера: <br/>
```
   docker run -p 8001:8000 -v $(pwd)/../models:/models estate_model:0
```

### 6. Проверка роботоспособности сервиса
Подставим в тело запроса одну строку из датафрейма в виде JSON-объекта:
```
 {
    "battery_power": 1434,
    "blue": 0,
    "clock_speed": 1.4,
    "dual_sim": 0,
    "fc": 11,
    "four_g": 1,
    "int_memory": 49,
    "m_dep": 0.5,
    "mobile_wt": 108,
    "n_cores": 6,
    "pc": 18,
    "px_height": 749,
    "px_width": 810,
    "ram": 1773,
    "sc_h": 15,
    "sc_w": 8,
    "talk_time": 7,
    "three_g": 1,
    "touch_screen": 0,
    "wifi": 1
}
```
Сервис должен возвращать значение price_range от 0 до 3 и тем самым мы понимаем к какому ценовому сегменту относится данный телефон.